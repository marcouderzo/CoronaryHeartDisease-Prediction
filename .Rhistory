f1.score
### QDA
qda.fit <- qda(HeartDisease~., data=train)
qda.pred <- predict(qda.fit, test)
qda.pred.t3<- as.factor(ifelse(qda.pred$posterior[,2] > 0.3, 1, 0))
qda.pred.t4<- as.factor(ifelse(qda.pred$posterior[,2] > 0.4, 1, 0))
qda.pred.t5<- as.factor(ifelse(qda.pred$posterior[,2] > 0.5, 1, 0))
qda.pred.t6<- as.factor(ifelse(qda.pred$posterior[,2] > 0.6, 1, 0))
conf.mat <- table(qda.pred.t5, test$HeartDisease)
acc <- sum(diag(conf.mat))/sum(conf.mat)
prec <- conf.mat[2,2] / sum(conf.mat[,2])
rec <- conf.mat[2,2] / sum(conf.mat[2,])
f1.score <- 2*prec*rec/(prec+rec)
roc.out <- roc(controls=test$HeartDisease, cases=qda.pred$posterior[,2],
direction=">")
plot(roc.out, print.auc=TRUE, legacy.axes=TRUE,
xlab="False positive rate", ylab="True positive rate")
auc(roc.out)
acc
prec
rec
f1.score
# KNN
# TODO: use also categorical variables
knn.pred <- knn(X.train[, -c(2, 3, 7, 9, 11)], X.test[, -c(2, 3, 7, 9, 11)],
y.train, k=5)
table(knn.pred, y.test)
96/(96+31)
# ANOVA
# TODO: study meaning of this
sex.aov <- aov(Age ~ Sex)
summary(sex.aov)
cont.val
# ANOVA
# TODO: study meaning of this
sex.aov <- aov(Age ~ RestingBP)
summary(sex.aov)
# ANOVA
# TODO: study meaning of this
sex.aov <- aov(Age ~ Cholesterol)
summary(sex.aov)
# ANOVA
# TODO: study meaning of this
sex.aov <- aov(Age ~ FastingBS)
summary(sex.aov)
# ANOVA
# TODO: study meaning of this
sex.aov <- aov(Age ~ MaxHR)
summary(sex.aov)
# ANOVA
# TODO: study meaning of this
sex.aov <- aov(Age ~ Oldpeak)
summary(sex.aov)
# ANOVA
# TODO: study meaning of this
sex.aov <- aov(Cholesterol ~ Sex)
summary(sex.aov)
# ANOVA
# TODO: study meaning of this
sex.aov <- aov(Age ~ Sex)
sex.aov.2 <- aov(Age ~ Sex)
summary(sex.aov)
# QQ plots
qqnorm(Cholesterol, pch = 1, frame = FALSE)
qqline(Cholesterol)
cont.val
# QQ plots
qqnorm(Age, pch = 1, frame = FALSE)
qqline(Age)
# QQ plots
qqnorm(Age, pch = 1, frame = FALSE)
qqline(Age)
qqline(Age, col="blue")
qqline(Age, col="steelblue")
qqline(Age, col="steelblue", lwd=2)
qqline(Age, col="steelblue")
qqline(Age, col="steelblue")
# QQ plots
qqnorm(Age, pch = 1, frame = FALSE)
qqline(Age, col="steelblue")
cont.val
# QQ plots
qqnorm(RestingBP, pch = 1, frame = FALSE)
qqline(RestingBP, col="steelblue")
# QQ plots
qqnorm(MaxHR, pch = 1, frame = FALSE)
qqline(MaxHR, col="steelblue")
# QQ plots
qqnorm(Oldpeak, pch = 1, frame = FALSE)
qqline(Oldpeak, col="steelblue")
# QQ plots
qqnorm(FastingBS, pch = 1, frame = FALSE)
qqline(FastingBS, col="steelblue")
# QQ plots
qqnorm(Cholesterol, pch = 1, frame = FALSE)
qqline(Cholesterol, col="steelblue")
size(X.train)
dim(X.train)
### LDA
lda.fit <- lda(HeartDisease~., data=train)
library(MASS)
### LDA
lda.fit <- lda(HeartDisease~., data=train)
plot(lda.fit, type="density")
lda.pred <- predict(lda.fit, test, type="response")
lda.res <- lda.pred$posterior
lda.pred.t3 <- as.factor(ifelse(lda.res[,2] > 0.3, 1, 0))
lda.pred.t4 <- as.factor(ifelse(lda.res[,2] > 0.4, 1, 0))
lda.pred.t5 <- lda.pred$class
# the best result is when t = 4 if we want to minimize False Positives
conf.mat <- table(test$HeartDisease, lda.pred.t4)
conf.mat
# error rate
mean(lda.pred.t4!=test$HeartDisease)
acc <- sum(diag(conf.mat))/sum(conf.mat)
prec <- conf.mat[2,2] / sum(conf.mat[,2])
rec <- conf.mat[2,2] / sum(conf.mat[2,])
f1.score <- 2*prec*rec/(prec+rec)
roc.out <- roc(controls=test$HeartDisease, cases=lda.pred$posterior[,2],
direction=">")
library(pROC)
roc.out <- roc(controls=test$HeartDisease, cases=lda.pred$posterior[,2],
direction=">")
plot(roc.out, print.auc=TRUE, legacy.axes=TRUE,
xlab="False positive rate", ylab="True positive rate")
auc(roc.out)
acc
prec
rec
summary(data)
# Age
age.plot.1 <- ggplot(data, aes(x=Age, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_density(alpha=0.4) +
ggtitle("Age - Density Plot") + xlab("Age") +
guides(fill = guide_legend(title="Heart disease"))
library(MASS)
library(pROC)
library(class)
library(ggplot2)
library(gridExtra)
library(corrplot)
library(tidymodels)
library(naivebayes)
# Age
age.plot.1 <- ggplot(data, aes(x=Age, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_density(alpha=0.4) +
ggtitle("Age - Density Plot") + xlab("Age") +
guides(fill = guide_legend(title="Heart disease"))
age.plot.1
# Age
age.plot.1 <- ggplot(data, aes(x=Age, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_density(alpha=0.4) +
ggtitle("Age - Density Plot") + xlab("Age") +
guides(fill = guide_legend(title="Heart disease"))
age.plot.1
# visualizing the data
# continuous variables
colours <- c("#F8766D", "#00BFC4")
# Age
age.plot.1 <- ggplot(data, aes(x=Age, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_density(alpha=0.4) +
ggtitle("Age - Density Plot") + xlab("Age") +
guides(fill = guide_legend(title="Heart disease"))
age.plot.1
data.orig <- read.csv("data/heart_data.csv", stringsAsFactors = T)
head(data.orig)
# we get the shape of the dataframe
nrows <- dim(data.orig)[1]
ncols <- dim(data.orig)[2]
# we check if there are missing values
anyNA(data.orig)
# copy of dataset in case I need to change it
data <- data.frame(data.orig)
attach(data)
# data balance check
prop.table(table(HeartDisease))
# continuous variables
cont.val <- c("Age", "RestingBP", "Cholesterol", "FastingBS", "MaxHR",
"Oldpeak")
# categorical variables
cat.val <- c("Sex", "ChestPainType", "RestingECG", "ExerciseAngina", "ST_Slope")
# visualizing the data
# continuous variables
colours <- c("#F8766D", "#00BFC4")
# Age
age.plot.1 <- ggplot(data, aes(x=Age, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_density(alpha=0.4) +
ggtitle("Age - Density Plot") + xlab("Age") +
guides(fill = guide_legend(title="Heart disease"))
age.plot.1
glm.model <- glm(data=train, HeartDisease~., family="binomial")
glm_summary <- summary(glm.model)
glm_summary
dev.off()
# Age
age.plot.1 <- ggplot(data, aes(x=Age, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_density(alpha=0.4) +
ggtitle("Age - Density Plot") + xlab("Age") +
guides(fill = guide_legend(title="Heart disease"))
age.plot.1
summary(data)
attach(data)
# QQ plots
# TODO: what if data doesn't follow normal distribution?
qqnorm(Age, pch = 1, frame = FALSE)
# QQ plots
# TODO: what if data doesn't follow normal distribution?
qqnorm(Age, pch = 1, frame = FALSE)
qqline(Age, col="steelblue")
qqnorm(RestingBP, pch = 1, frame = FALSE)
qqline(RestingBP, col="steelblue")
qqnorm(Cholesterol, pch = 1, frame = FALSE)
qqline(Cholesterol, col="steelblue")
qqnorm(MaxHR, pch = 1, frame = FALSE)
qqline(MaxHR, col="steelblue")
qqnorm(Oldpeak, pch = 1, frame = FALSE)
qqline(Oldpeak, col="steelblue")
calculate.metrics <- function(conf.mat) {
acc <- sum(diag(conf.mat))/sum(conf.mat)
prec <- conf.mat[2,2] / sum(conf.mat[,2])
rec <- conf.mat[2,2] / sum(conf.mat[2,])
f1.score <- 2*prec*rec/(prec+rec)
out <- list(acc, prec, rec, f1.score)
return out
return(out)
calculate.metrics <- function(conf.mat) {
acc <- sum(diag(conf.mat))/sum(conf.mat)
prec <- conf.mat[2,2] / sum(conf.mat[,2])
rec <- conf.mat[2,2] / sum(conf.mat[2,])
f1.score <- 2*prec*rec/(prec+rec)
out <- list(acc, prec, rec, f1.score)
return(out)
}
### LDA
lda.fit <- lda(HeartDisease~., data=train)
library(MASS)
library(pROC)
library(class)
library(ggplot2)
library(gridExtra)
library(corrplot)
library(tidymodels)
library(naivebayes)
library(ROCR)
library(glmnet)
### LDA
lda.fit <- lda(HeartDisease~., data=train)
plot(lda.fit, type="density")
lda.pred <- predict(lda.fit, test, type="response")
lda.res <- lda.pred$posterior
lda.pred.t3 <- as.factor(ifelse(lda.res[,2] > 0.3, 1, 0))
lda.pred.t4 <- as.factor(ifelse(lda.res[,2] > 0.4, 1, 0))
lda.pred.t5 <- lda.pred$class
# the best result is when t = 4 if we want to minimize False Positives
conf.mat <- table(test$HeartDisease, lda.pred.t4)
conf.mat
calculate.metrics(conf.mat)
### QDA
qda.fit <- qda(HeartDisease~., data=train)
qda.pred <- predict(qda.fit, test)
qda.pred.t3<- as.factor(ifelse(qda.pred$posterior[,2] > 0.3, 1, 0))
qda.pred.t4<- as.factor(ifelse(qda.pred$posterior[,2] > 0.4, 1, 0))
qda.pred.t5<- as.factor(ifelse(qda.pred$posterior[,2] > 0.5, 1, 0))
qda.pred.t6<- as.factor(ifelse(qda.pred$posterior[,2] > 0.6, 1, 0))
conf.mat <- table(qda.pred.t5, test$HeartDisease)
metrics <- calculate.metrics(conf.mat)
metrics
lda.pred.t4
lda.pred
plot(lda.perf, main="ROC")
# TODO: check manually thresholds to verify the behaviour of the curve
# TODO: data taken after prediction -> check dataset
lda.perf <- performance(lda.pred, measure="tpr", x.measure="fpr")
lda.pred
# TODO: check manually thresholds to verify the behaviour of the curve
# TODO: data taken after prediction -> check dataset
lda.pred.roc <- prediction(lda.pred, test$HeartDisease)
lda.pred
# TODO: check manually thresholds to verify the behaviour of the curve
# TODO: data taken after prediction -> check dataset
lda.pred.roc <- prediction(lda.pred.t4, test$HeartDisease)
lda.pred.t4
glm.model <- glm(data=train, HeartDisease~., family="binomial")
glm_summary <- summary(glm.model)
#calculate odds of success given R-squared value
r2 <- 1 - (glm_summary$deviance/glm_summary$null.deviance) # null.deviance: deviance of model with only intercept term.
1/(1-r2) # odds of success for a particular observation in logistic regression model: probability of success / probability of failure
# prediction and conversion to binary
prediction.glm.model <- predict(glm.model, newdata=test, type="response")
prediction.glm.model.binary <- ifelse(prediction.glm.model > 0.6, 1, 0)
conf_matrix <- table(test$HeartDisease, prediction.glm.model.binary) #tried also with correlationMatrix from carel package but having problems with levels
mean(prediction.glm.model.binary != test$HeartDisease) #how many are wrong
accuracy <- sum(diag(conf_matrix))/sum(conf_matrix) # proportion of correct predictions
precision <- conf_matrix[2,2] / sum(conf_matrix[,2]) # true positive rate
recall <- conf_matrix[2,2] / sum(conf_matrix[2,]) # sensitivity
cat("Accuracy:", round(accuracy, 3), "\n") # Accuracy 0.875
cat("Precision:", round(precision, 3), "\n") # Precision: 0.9
cat("Recall:", round(recall, 3), "\n") # Recall: 0.908
cat("Confusion Matrix:\n")
print(conf_matrix)
# Removing Age
glm.model <- glm(data=train, HeartDisease~. - Age, family="binomial")
glm_summary <- summary(glm.model)
summary(glm.model)
#calculate odds of success given R-squared value
r2 <- 1 - (glm_summary$deviance/glm_summary$null.deviance)
1/(1-r2)
# prediction and conversion to binary
prediction.glm.model <- predict(glm.model, newdata=test, type="response")
prediction.glm.model.binary <- ifelse(prediction.glm.model > 0.6, 1, 0)
conf_matrix <- table(test$HeartDisease, prediction.glm.model.binary)
mean(prediction.glm.model.binary != test$HeartDisease)
accuracy <- sum(diag(conf_matrix))/sum(conf_matrix) # proportion of correct predictions
precision <- conf_matrix[2,2] / sum(conf_matrix[,2]) # true positive rate
recall <- conf_matrix[2,2] / sum(conf_matrix[2,]) # sensitivity
cat("Accuracy:", round(accuracy, 3), "\n") # Accuracy: 0.88
cat("Precision:", round(precision, 3), "\n") # Precision: 0.901
cat("Recall:", round(recall, 3), "\n") # Recall: 0.916
cat("Confusion Matrix:\n")
print(conf_matrix)
# Removing RestingECG
glm.model <- glm(data=train, HeartDisease~. - Age - RestingECG, family="binomial")
glm_summary <- summary(glm.model)
summary(glm.model)
#calculate odds of success given R-squared value
r2 <- 1 - (glm_summary$deviance/glm_summary$null.deviance)
1/(1-r2)
# prediction and conversion to binary
prediction.glm.model <- predict(glm.model, newdata=test, type="response")
prediction.glm.model.binary <- ifelse(prediction.glm.model > 0.6, 1, 0)
conf_matrix <- table(test$HeartDisease, prediction.glm.model.binary)
mean(prediction.glm.model.binary != test$HeartDisease)
accuracy <- sum(diag(conf_matrix))/sum(conf_matrix) # proportion of correct predictions
precision <- conf_matrix[2,2] / sum(conf_matrix[,2]) # true positive rate
recall <- conf_matrix[2,2] / sum(conf_matrix[2,]) # sensitivity
cat("Accuracy:", round(accuracy, 3), "\n") # Accuracy: 0.875
cat("Precision:", round(precision, 3), "\n") # Precision: 0.914
cat("Recall:", round(recall, 3), "\n") # Recall: 0.916 -> 0.891
cat("Confusion Matrix:\n")
print(conf_matrix)
# Removing MaxHR
glm.model <- glm(data=train, HeartDisease~. - Age - RestingECG - MaxHR, family="binomial")
glm_summary <- summary(glm.model)
summary(glm.model)
#calculate odds of success given R-squared value
r2 <- 1 - (glm_summary$deviance/glm_summary$null.deviance)
1/(1-r2)
# prediction and conversion to binary
prediction.glm.model <- predict(glm.model, newdata=test, type="response")
prediction.glm.model.binary <- ifelse(prediction.glm.model > 0.4, 1, 0)
conf_matrix <- table(test$HeartDisease, prediction.glm.model.binary)
mean(prediction.glm.model.binary != test$HeartDisease)
accuracy <- sum(diag(conf_matrix))/sum(conf_matrix) # proportion of correct predictions
precision <- conf_matrix[2,2] / sum(conf_matrix[,2]) # true positive rate
recall <- conf_matrix[2,2] / sum(conf_matrix[2,]) # sensitivity
cat("Accuracy:", round(accuracy, 3), "\n") # Accuracy: 0.897
cat("Precision:", round(precision, 3), "\n") # Precision: 0.917
cat("Recall:", round(recall, 3), "\n") # Recall: 0.916 -> 0.891 -> 0.924
cat("Confusion Matrix:\n")
print(conf_matrix)
pred <- prediction(prediction.glm.model.binary, test$HeartDisease)
perf <- performance(pred, measure = "tpr", x.measure = "fpr")
# Plot the ROC curve
plot(perf, main="ROC Curve", colorize=T)
lda.pred
prediction.glm.model
lda.pred$posterior
lda.pred$posterior[1,:]
lda.pred$posterior(1,:)
tmp <- lda.pred$posterior
tmp(1,:)
tmp[1,:]
lda.pred <- predict(lda.fit, test, type="response")
lda.res <- lda.pred$posterior
lda.res
# Removing MaxHR
glm.model <- glm(data=train, HeartDisease~. - Age - RestingECG - MaxHR, family="binomial")
glm_summary <- summary(glm.model)
summary(glm.model)
# prediction and conversion to binary
prediction.glm.model <- predict(glm.model, newdata=test, type="response")
prediction.glm.model.binary <- ifelse(prediction.glm.model > 0.4, 1, 0)
prediction.glm.model
lda.res[1]
lda.res[1,]
lda.res[,1]
# TODO: check manually thresholds to verify the behaviour of the curve
# TODO: data taken after prediction -> check dataset
pred <- prediction(lda.res[,2], test$HeartDisease)
perf <- performance(pred, measure="tpr", x.measure="fpr")
plot(lda.perf, main="ROC")
plot(perf, main="ROC")
plot(perf, main="ROC")
# TODO: check manually thresholds to verify the behaviour of the curve
# TODO: data taken after prediction -> check dataset
pred <- prediction(lda.res[,2], test$HeartDisease)
perf <- performance(pred, measure="tpr", x.measure="fpr")
plot(perf, main="ROC")
plot(perf, main="ROC")
# TODO: check manually thresholds to verify the behaviour of the curve
# TODO: data taken after prediction -> check dataset
model.plot.roc(lda.res[,2], test$HeartDisease)
model.plot.roc <- function(predm, labl) {
pred <- prediction(predm, labl)
perf <- performance(pred, measure="tpr", x.measure="fpr")
plot(perf, main="ROC")
}
# TODO: check manually thresholds to verify the behaviour of the curve
# TODO: data taken after prediction -> check dataset
model.plot.roc(lda.res[,2], test$HeartDisease)
model.plot.roc(qda.pred$posterior[,2], test$HeartDisease)
abline(a=0, b= 1)
model.plot.roc <- function(predm, labl) {
pred <- prediction(predm, labl)
perf <- performance(pred, measure="tpr", x.measure="fpr")
plot(perf, main="ROC")
abline(a=0, b= 1)
}
# TODO: check manually thresholds to verify the behaviour of the curve
# TODO: data taken after prediction -> check dataset
model.plot.roc(lda.res[,2], test$HeartDisease)
model.plot.roc(qda.pred$posterior[,2], test$HeartDisease)
model.plot.roc <- function(predm, labl) {
pred <- prediction(predm, labl)
perf <- performance(pred, measure="tpr", x.measure="fpr")
plot(perf, main="ROC")
abline(a=0, b= 1)
auc.perf <- performance(pred, measure = "auc")
return(auc.perf@y.values)
}
# TODO: check manually thresholds to verify the behaviour of the curve
# TODO: data taken after prediction -> check dataset
lda.auc <- model.plot.roc(lda.res[,2], test$HeartDisease)
lda.auc
qda.auc <- model.plot.roc(qda.pred$posterior[,2], test$HeartDisease)
qda.auc
lda.pred.test <- as.factor(ifelse(lda.res[,2] > 0, 1, 0))
# the best result is when t = 4 if we want to minimize False Positives
conf.mat <- table(test$HeartDisease, lda.pred.test)
conf.mat
lda.pred.test <- as.factor(ifelse(lda.res[,2] > 0.1, 1, 0))
# the best result is when t = 4 if we want to minimize False Positives
conf.mat <- table(test$HeartDisease, lda.pred.test)
conf.mat
125/(125+45)
45/(125+45)
lda.pred.test <- as.factor(ifelse(lda.res[,2] > 0.2, 1, 0))
# the best result is when t = 4 if we want to minimize False Positives
conf.mat <- table(test$HeartDisease, lda.pred.test)
conf.mat
122/(122+34)
lda.pred.test <- as.factor(ifelse(lda.res[,2] > 0.3, 1, 0))
# the best result is when t = 4 if we want to minimize False Positives
conf.mat <- table(test$HeartDisease, lda.pred.test)
conf.mat
119/(26+119)
lda.pred.test <- as.factor(ifelse(lda.res[,2] > 0.5, 1, 0))
# the best result is when t = 4 if we want to minimize False Positives
conf.mat <- table(test$HeartDisease, lda.pred.test)
conf.mat
113/(113+15)
lda.pred.test <- as.factor(ifelse(lda.res[,2] > 0.4, 1, 0))
# the best result is when t = 4 if we want to minimize False Positives
conf.mat <- table(test$HeartDisease, lda.pred.test)
conf.mat
115/(115+21)
lda.pred.test <- as.factor(ifelse(lda.res[,2] > 0.6, 1, 0))
# the best result is when t = 4 if we want to minimize False Positives
conf.mat <- table(test$HeartDisease, lda.pred.test)
conf.mat
110/(110+13)
lda.pred.test <- as.factor(ifelse(lda.res[,2] > 0.7, 1, 0))
# the best result is when t = 4 if we want to minimize False Positives
conf.mat <- table(test$HeartDisease, lda.pred.test)
conf.mat
108/(108+13)
lda.pred.test <- as.factor(ifelse(lda.res[,2] > 0.8, 1, 0))
# the best result is when t = 4 if we want to minimize False Positives
conf.mat <- table(test$HeartDisease, lda.pred.test)
conf.mat
lda.pred.test <- as.factor(ifelse(lda.res[,2] > 0.6, 1, 0))
# the best result is when t = 4 if we want to minimize False Positives
conf.mat <- table(test$HeartDisease, lda.pred.test)
conf.mat
# error rate
mean(lda.pred.test!=test$HeartDisease)
metrics <- calculate.metrics(conf.mat)
metrics
lda.pred.best <- as.factor(ifelse(lda.res[,2] > 0.4, 1, 0))
# the best result is when t = 4 if we want to minimize False Positives
conf.mat <- table(test$HeartDisease, lda.pred.best)
conf.mat
# error rate
mean(lda.pred.best!=test$HeartDisease)
metrics <- calculate.metrics(conf.mat)
metrics
lda.pred.best <- as.factor(ifelse(lda.res[,2] > 0.6, 1, 0))
# the best result is when t = 4 if we want to minimize False Positives
conf.mat <- table(test$HeartDisease, lda.pred.best)
conf.mat
# error rate
mean(lda.pred.best!=test$HeartDisease)
metrics <- calculate.metrics(conf.mat)
metrics
lda.pred$class
lda.auc <- model.plot.roc(lda.res[,2], test$HeartDisease)
