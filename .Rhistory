k <- ols_step_forward_p(prediction.glm.model.binary)
library(MASS)
library(pROC)
library(class)
library(ggplot2)
library(corrplot)
library(tidymodels)
library(naivebayes)
data.orig <- read.csv("data/heart_data.csv", stringsAsFactors = T)
head(data.orig)
# we get the shape of the dataframe
nrows <- dim(data.orig)[1]
ncols <- dim(data.orig)[2]
# we check if there are missing values
anyNA(data.orig)
# copy of dataset in case I need to change it
data <- data.frame(data.orig)
attach(data)
# data balance check
prop.table(table(HeartDisease))
# visualizing the data
# TODO: implement better legend and better graphics
barplot(table(ChestPainType))
counts <- table(Sex, HeartDisease)
barplot(counts, beside=T, names.arg=c("Normal", "Heart disease"),
legend.text = c("M", "F"))
counts <- table(ChestPainType, HeartDisease)
barplot(counts, beside=T, names.arg=c("Normal", "Heart disease"),
legend.text = T)
boxplot(Age ~ HeartDisease)
hist(Age)
boxplot(RestingBP ~ HeartDisease)
hist(RestingBP)
boxplot(Cholesterol ~ HeartDisease)
ggplot(data, aes(x = Cholesterol, fill=HeartDisease)) +
geom_density(alpha = 0.4) +
facet_grid(~HeartDisease)
counts <- table(FastingBS, HeartDisease)
barplot(counts, beside=T, names.arg=c("Normal", "Heart disease"),
legend.text = T)
counts <- table(RestingECG, HeartDisease)
barplot(counts, beside=T, names.arg=c("Normal", "Heart disease"),
legend.text = T)
boxplot(MaxHR ~ HeartDisease)
hist(MaxHR)
counts <- table(ExerciseAngina, HeartDisease)
barplot(counts, beside=T, names.arg=c("Normal", "Heart disease"),
legend.text = T)
boxplot(Oldpeak ~ HeartDisease)
hist(Oldpeak)
counts <- table(ST_Slope, HeartDisease)
barplot(counts, beside=T, names.arg=c("Normal", "Heart disease"),
legend.text = T)
# dealing with missing values
RestingBP[RestingBP == 0] <- median(RestingBP)
# correlation matrix
nums <- unlist(lapply(data, is.numeric), use.names = FALSE)
cor.data <- cor(data[, nums])
corrplot(cor.data,
method="color",
diag=F,
tl.cex=0.4,
number.cex=0.5,
tl.col="black",
addCoef.col="grey50",
cl.pos="n")
# Train-Test split
set.seed(42)
split <- initial_split(data, prop=0.80)
train <- training(split)
test <- testing(split)
y.train <- train$HeartDisease
X.train <- train[, !names(train) %in% c("HeartDisease")]
y.test <- test$HeartDisease
X.test <- test[, !names(test) %in% c("HeartDisease")]
glm.model <- glm(data=train, HeartDisease~., family="binomial")
glm_summary <- summary(glm.model)
#calculate odds of success given R-squared value
r2 <- 1 - (glm_summary$deviance/glm_summary$null.deviance) # null.deviance: deviance of model with only intercept term.
1/(1-r2) # odds of success for a particular observation in logistic regression model: probability of success / probability of failure
# prediction and conversion to binary
prediction.glm.model <- predict(glm.model, newdata=test, type="response")
prediction.glm.model.binary <- ifelse(prediction.glm.model > 0.6, 1, 0)
conf_matrix <- table(test$HeartDisease, prediction.glm.model.binary) #tried also with correlationMatrix from carel package but having problems with levels
mean(prediction.glm.model.binary != test$HeartDisease) #how many are wrong
accuracy <- sum(diag(conf_matrix))/sum(conf_matrix) # proportion of correct predictions
precision <- conf_matrix[2,2] / sum(conf_matrix[,2]) # true positive rate
recall <- conf_matrix[2,2] / sum(conf_matrix[2,]) # sensitivity
cat("Accuracy:", round(accuracy, 3), "\n")
cat("Precision:", round(precision, 3), "\n")
cat("Recall:", round(recall, 3), "\n")
cat("Confusion Matrix:\n")
print(conf_matrix)
k <- ols_step_forward_p(prediction.glm.model.binary)
library(olsrr)
k <- ols_step_forward_p(prediction.glm.model.binary)
k <- ols_step_forward_p(prediction.glm.model)
k <- ols_step_forward_p(prediction.glm.model)
library(MASS)
library(pROC)
library(class)
library(ggplot2)
library(gridExtra)
library(corrplot)
library(tidymodels)
library(naivebayes)
library(ROCR)
library(glmnet)
data.orig <- read.csv("data/heart_data.csv", stringsAsFactors = T)
head(data.orig)
# we get the shape of the dataframe
nrows <- dim(data.orig)[1]
ncols <- dim(data.orig)[2]
# we check if there are missing values
anyNA(data.orig)
# copy of dataset in case I need to change it
data <- data.frame(data.orig)
attach(data)
# data balance check
prop.table(table(HeartDisease))
# continuous variables
cont.val <- c("Age", "RestingBP", "Cholesterol", "FastingBS", "MaxHR",
"Oldpeak")
# categorical variables
cat.val <- c("Sex", "ChestPainType", "RestingECG", "ExerciseAngina", "ST_Slope")
# visualizing the data
# continuous variables
colours <- c("#F8766D", "#00BFC4")
# Age
age.plot.1 <- ggplot(data, aes(x=Age, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_density(alpha=0.4) +
ggtitle("Age - Density Plot") + xlab("Age") +
guides(fill = guide_legend(title="Heart disease"))
age.plot.2 <- ggplot(data, aes(x=Age, group=Sex,
fill=factor(Sex))) +
geom_density(alpha=0.4) +
ggtitle("Age - Density Plot") + xlab("Age") +
guides(fill = guide_legend(title="Gender"))
# RestingBP
restingBP.plot <- ggplot(data, aes(x=RestingBP, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_density(alpha=0.4) +
ggtitle("RestingBP - Density Plot") + xlab("RestingBP") +
guides(fill = guide_legend(title="Heart disease"))
# Cholesterol
chol.plot <- ggplot(data, aes(x=Cholesterol, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_density(alpha=0.4) +
ggtitle("Cholesterol - Density Plot") + xlab("Cholesterol") +
guides(fill = guide_legend(title="Heart disease"))
# MaxHR
maxHR.plot <- ggplot(data, aes(x=MaxHR, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_density(alpha=0.4) +
ggtitle("MaxHR - Density Plot") + xlab("MaxHR") +
guides(fill = guide_legend(title="Heart disease"))
# Oldpeak
oldpeak.plot <- ggplot(data, aes(x=Oldpeak, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_density(alpha=0.4) +
ggtitle("Oldpeak - Density Plot") + xlab("Oldpeak") +
guides(fill = guide_legend(title="Heart disease"))
grid.arrange(age.plot.1, age.plot.2, restingBP.plot, chol.plot, maxHR.plot,
oldpeak.plot, nrow = 2)
# FastingBS
fastingBS.plot <- ggplot(data, aes(x=FastingBS, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_bar(alpha=0.5, position="dodge") +
guides(fill = guide_legend(title="Heart disease"))
# Boxplots
# TODO: should we deal with outliers?
age.box.1 <- boxplot(Age ~ HeartDisease, col=colours)
age.box.2 <- boxplot(Age ~ Sex, col=colours)
restingBP.box <- boxplot(RestingBP ~ HeartDisease, col=colours) # TODO: check outliers?
chol.box <- boxplot(Cholesterol ~ HeartDisease, col=colours)
maxHR.box <- boxplot(MaxHR ~ HeartDisease, col=colours)
oldpeak.box <- boxplot(Oldpeak ~ HeartDisease, col=colours)
# categorical variables
# Sex
sex.plot <- ggplot(data, aes(x=Sex, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_bar(alpha=0.5, position="dodge") +
guides(fill = guide_legend(title="Heart disease"))
# ChestPainType
cpt.plot <- ggplot(data, aes(x=ChestPainType, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_bar(alpha=0.5, position="dodge") +
guides(fill = guide_legend(title="Heart disease"))
# RestingECG
restingECG.plot <- ggplot(data, aes(x=RestingECG, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_bar(alpha=0.5, position="dodge") +
guides(fill = guide_legend(title="Heart disease"))
# ExerciseAngina
exAn.plot <- ggplot(data, aes(x=ExerciseAngina, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_bar(alpha=0.5, position="dodge") +
guides(fill = guide_legend(title="Heart disease"))
# ST_Slope
st.plot <- ggplot(data, aes(x=ST_Slope, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_bar(alpha=0.5, position="dodge") +
guides(fill = guide_legend(title="Heart disease"))
# QQ plots
# TODO: what if data doesn't follow normal distribution?
qqnorm(Age, pch = 1, frame = FALSE)
qqline(Age, col="steelblue")
qqnorm(RestingBP, pch = 1, frame = FALSE)
qqline(RestingBP, col="steelblue")
qqnorm(Cholesterol, pch = 1, frame = FALSE)
qqline(Cholesterol, col="steelblue")
qqnorm(MaxHR, pch = 1, frame = FALSE)
qqline(MaxHR, col="steelblue")
qqnorm(Oldpeak, pch = 1, frame = FALSE)
qqline(Oldpeak, col="steelblue")
# dealing with missing values
RestingBP[RestingBP == 0] <- median(RestingBP)
# ANOVA
# TODO: study meaning of this
# TODO: chi-square test?
sex.aov <- aov(HeartDisease ~ Sex)
summary(sex.aov)
sex.aov.2 <- aov(Age ~ Sex)
summary(sex.aov) # TODO: why high p-value?
cpt.aov <- aov(HeartDisease ~ ChestPainType)
summary(cpt.aov)
restingECG.aov <- aov(HeartDisease ~ RestingECG)
summary(restingECG.aov)
exAn.aov <- aov(HeartDisease ~ ExerciseAngina)
summary(exAn.aov)
st.aov <- aov(HeartDisease ~ ST_Slope)
summary(sex.aov)
# correlations
cor(Age, HeartDisease)
cor(RestingBP, HeartDisease)
cor(Cholesterol, HeartDisease)
cor(FastingBS, HeartDisease)
cor(MaxHR, HeartDisease)
cor(Oldpeak, HeartDisease)
# correlation matrix
nums <- unlist(lapply(data, is.numeric), use.names = FALSE)
cor.data <- cor(data[, nums])
corrplot(cor.data,
method="color",
diag=F,
tl.cex=0.4,
number.cex=0.5,
tl.col="black",
addCoef.col="grey50",
cl.pos="n")
# Train-Test split
set.seed(123)
split <- initial_split(data, prop=0.75)
train <- training(split)
test <- testing(split)
y.train <- train$HeartDisease
X.train <- train[, !names(train) %in% c("HeartDisease")]
y.test <- test$HeartDisease
X.test <- test[, !names(test) %in% c("HeartDisease")]
glm.model <- glm(data=train, HeartDisease~., family="binomial")
glm_summary <- summary(glm.model)
#calculate odds of success given R-squared value
r2 <- 1 - (glm_summary$deviance/glm_summary$null.deviance) # null.deviance: deviance of model with only intercept term.
1/(1-r2) # odds of success for a particular observation in logistic regression model: probability of success / probability of failure
# prediction and conversion to binary
prediction.glm.model <- predict(glm.model, newdata=test, type="response")
prediction.glm.model.binary <- ifelse(prediction.glm.model > 0.6, 1, 0)
conf_matrix <- table(test$HeartDisease, prediction.glm.model.binary) #tried also with correlationMatrix from carel package but having problems with levels
mean(prediction.glm.model.binary != test$HeartDisease) #how many are wrong
accuracy <- sum(diag(conf_matrix))/sum(conf_matrix) # proportion of correct predictions
precision <- conf_matrix[2,2] / sum(conf_matrix[,2]) # true positive rate
recall <- conf_matrix[2,2] / sum(conf_matrix[2,]) # sensitivity
cat("Accuracy:", round(accuracy, 3), "\n") # Accuracy 0.875
cat("Precision:", round(precision, 3), "\n") # Precision: 0.9
cat("Recall:", round(recall, 3), "\n") # Recall: 0.908
cat("Confusion Matrix:\n")
print(conf_matrix)
# Removing Age
glm.model <- glm(data=train, HeartDisease~. - Age, family="binomial")
glm_summary <- summary(glm.model)
summary(glm.model)
#calculate odds of success given R-squared value
r2 <- 1 - (glm_summary$deviance/glm_summary$null.deviance)
1/(1-r2)
# prediction and conversion to binary
prediction.glm.model <- predict(glm.model, newdata=test, type="response")
prediction.glm.model.binary <- ifelse(prediction.glm.model > 0.6, 1, 0)
conf_matrix <- table(test$HeartDisease, prediction.glm.model.binary)
mean(prediction.glm.model.binary != test$HeartDisease)
accuracy <- sum(diag(conf_matrix))/sum(conf_matrix) # proportion of correct predictions
precision <- conf_matrix[2,2] / sum(conf_matrix[,2]) # true positive rate
recall <- conf_matrix[2,2] / sum(conf_matrix[2,]) # sensitivity
cat("Accuracy:", round(accuracy, 3), "\n") # Accuracy: 0.88
cat("Precision:", round(precision, 3), "\n") # Precision: 0.901
cat("Recall:", round(recall, 3), "\n") # Recall: 0.916
cat("Confusion Matrix:\n")
print(conf_matrix)
# Removing RestingECG
glm.model <- glm(data=train, HeartDisease~. - Age - RestingECG, family="binomial")
glm_summary <- summary(glm.model)
summary(glm.model)
#calculate odds of success given R-squared value
r2 <- 1 - (glm_summary$deviance/glm_summary$null.deviance)
1/(1-r2)
# prediction and conversion to binary
prediction.glm.model <- predict(glm.model, newdata=test, type="response")
prediction.glm.model.binary <- ifelse(prediction.glm.model > 0.6, 1, 0)
conf_matrix <- table(test$HeartDisease, prediction.glm.model.binary)
mean(prediction.glm.model.binary != test$HeartDisease)
accuracy <- sum(diag(conf_matrix))/sum(conf_matrix) # proportion of correct predictions
precision <- conf_matrix[2,2] / sum(conf_matrix[,2]) # true positive rate
recall <- conf_matrix[2,2] / sum(conf_matrix[2,]) # sensitivity
cat("Accuracy:", round(accuracy, 3), "\n") # Accuracy: 0.875
cat("Precision:", round(precision, 3), "\n") # Precision: 0.914
cat("Recall:", round(recall, 3), "\n") # Recall: 0.916 -> 0.891
cat("Confusion Matrix:\n")
print(conf_matrix)
# Removing MaxHR
glm.model <- glm(data=train, HeartDisease~. - Age - RestingECG - MaxHR, family="binomial")
glm_summary <- summary(glm.model)
summary(glm.model)
#calculate odds of success given R-squared value
r2 <- 1 - (glm_summary$deviance/glm_summary$null.deviance)
1/(1-r2)
# prediction and conversion to binary
prediction.glm.model <- predict(glm.model, newdata=test, type="response")
prediction.glm.model.binary <- ifelse(prediction.glm.model > 0.4, 1, 0)
conf_matrix <- table(test$HeartDisease, prediction.glm.model.binary)
mean(prediction.glm.model.binary != test$HeartDisease)
accuracy <- sum(diag(conf_matrix))/sum(conf_matrix) # proportion of correct predictions
precision <- conf_matrix[2,2] / sum(conf_matrix[,2]) # true positive rate
recall <- conf_matrix[2,2] / sum(conf_matrix[2,]) # sensitivity
cat("Accuracy:", round(accuracy, 3), "\n") # Accuracy: 0.897
cat("Precision:", round(precision, 3), "\n") # Precision: 0.917
cat("Recall:", round(recall, 3), "\n") # Recall: 0.916 -> 0.891 -> 0.924
cat("Confusion Matrix:\n")
print(conf_matrix)
pred <- prediction(prediction.glm.model.binary, test$HeartDisease)
perf <- performance(pred, measure = "tpr", x.measure = "fpr")
# Plot the ROC curve
plot(perf, main="ROC Curve", colorize=T)
X <- model.matrix(prediction.glm.model) #design matrix
y <- prediction.glm.model$HeartDisease #response vector
X <- model.matrix(prediction.glm.model) #design matrix
X <- model.matrix(prediction.glm.model$HeartDisease) #design matrix
X <- model.matrix(glm.model) #design matrix
y <- prediction.glm.model$HeartDisease #response vector
y <- glm.model$HeartDisease #response vector
lasso.model <- cv.glmnet(X, y, family = "binomial", type.measure = "class")
y
X <- model.matrix(glm.model)
lasso.model <- cv.glmnet(X, y, family = "binomial", type.measure = "class")
X <- model.matrix(glm.model)
y <- train$HeartDisease
lasso.model <- cv.glmnet(X, y, family = "binomial", type.measure = "class")
lasso.coef <- coef(lasso.model, s = "lambda.min")
lasso.vars <- rownames(lasso.coef)[-1][lasso.coef[-1,] != 0]
cat("Selected variables:", paste(lasso.vars, collapse = ", "))
fit <- cv.glmnet(X, y, family = "binomial", alpha = 0, type.measure = "deviance")
coef(fit, s = "lambda.min") # Extract the coefficients from the optimal model
train$HeartDisease <- as.factor(train$HeartDisease)
naivebayes.model <- naive_bayes(HeartDisease~., data=train)
prediction <- predict(naivebayes.model, train)
head(cbind(prediction, train))
naivebayes.conf_matrix <- table(prediction, test$HeartDisease)
help("len")
help("size")
shape(prediction)
dim(prediction)
prediction <- predict(naivebayes.model, train$HeartDisease)
prediction
naivebayes.model <- naive_bayes(HeartDisease~., data=train)
prediction <- predict(naivebayes.model, train)
p2rediction <- predict(naivebayes.model, train)
prediction <- predict(naivebayes.model, train)
naivebayes.conf_matrix <- table(prediction, test$HeartDisease)
prediction <- predict(naivebayes.model, train)
head(cbind(prediction, train$HeartDisease))
naivebayes.conf_matrix <- table(prediction, test$HeartDisease)
dim(prediction)
prediction
head(cbind(prediction, test$HeartDisease))
naivebayes.conf_matrix <- table(prediction, test$HeartDisease)
train$HeartDisease <- as.factor(train$HeartDisease)
test$HeartDisease <- as.factor(test$HeartDisease)
naivebayes.model <- naive_bayes(HeartDisease~., data=train)
prediction <- predict(naivebayes.model, test)
head(cbind(prediction, test$HeartDisease))
naivebayes.conf_matrix <- table(prediction, test$HeartDisease)
naivebayes.conf_matrix
logistic.regression.metrics <- calculate.metrics(conf_matrix)
calculate.metrics <- function(conf.mat) {
acc <- sum(diag(conf.mat))/sum(conf.mat)
prec <- conf.mat[2,2] / sum(conf.mat[,2])
rec <- conf.mat[2,2] / sum(conf.mat[2,])
f1.score <- 2*prec*rec/(prec+rec)
out <- list(acc, prec, rec, f1.score)
return(out)
}
model.plot.roc <- function(predm, labl) {
pred <- prediction(predm, labl)
perf <- performance(pred, measure="tpr", x.measure="fpr")
plot(perf, main="ROC")
abline(a=0, b= 1)
auc.perf <- performance(pred, measure = "auc")
return(auc.perf@y.values)
}
logreg.metrics <- calculate.metrics(conf_matrix)
logreg.metrics
glm.model.3.metrics <- calculate.metrics(conf_matrix)
glm.model.3.metrics
(conf_matrix)
conf_matrix
