library(gridExtra)
library(corrplot)
library(correlation)
library(ggm)
library(igraph)
library(tidymodels)
library(naivebayes)
library(ROCR)
library(glmnet)
# correlations
# correlation matrix
nums <- c(1,4,5,8,10)
cor.data <- cor(data[,nums])
corrplot(cor.data,
method="color",
diag=F,
tl.cex=0.4,
number.cex=0.5,
tl.col="black",
addCoef.col="grey50",
cl.pos="n")
# igraph
S <- var(data[,nums])
R <- -cov2cor(solve(S))
G <- abs(R)>0.1
diag(G) <- 0
G
# MaxHR
maxHR.plot <- ggplot(data, aes(x=MaxHR, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_density(alpha=0.4) +
ggtitle("MaxHR - Density Plot") + xlab("MaxHR") +
guides(fill = guide_legend(title="Heart disease"))
maxHR.plot
maxHR.box <- boxplot(MaxHR ~ HeartDisease, col=colours)
attach(data)
maxHR.box <- boxplot(MaxHR ~ HeartDisease, col=colours)
glm.model <- glm(data=train, HeartDisease~., family="binomial")
glm_summary <- summary(glm.model)
glm_summary
attach(data
)
# continuous variables
cont.val <- c(1,4,5,8,10)
data[,cont.val]
# continuous variables
cont.idx <- c(1,4,5,8,10)
rm(list=ls())
library(MASS)
library(pROC)
library(class)
library(ggplot2)
library(gridExtra)
library(corrplot)
library(ggm)
library(igraph)
library(tidymodels)
library(naivebayes)
library(ROCR)
library(glmnet)
data.orig <- read.csv("data/heart_data.csv", stringsAsFactors = T)
head(data.orig)
# we check if there are missing values
anyNA(data.orig)
# copy of dataset in case I need to change it
data <- data.frame(data.orig)
attach(data)
# data balance check
prop.table(table(HeartDisease))
# continuous variables
cont.idx <- c(1,4,5,8,10)
# visualizing the data
# continuous variables
colours <- c("#F8766D", "#00BFC4")
# correlations
cor.data <- cor(data[,cont.idx])
corrplot(cor.data,
method="color",
diag=F,
tl.cex=0.4,
number.cex=0.5,
tl.col="black",
addCoef.col="grey50",
cl.pos="n")
# igraph
S <- var(data[,nums])
# igraph
S <- var(data[,cont.idx])
R <- -cov2cor(solve(S))
G <- abs(R)>0.1
G
diag(G) <- 0
G
# Train-Test split
set.seed(123)
split <- initial_split(data, prop=0.75)
train <- training(split)
test <- testing(split)
calculate.metrics <- function(conf.mat) {
acc <- sum(diag(conf.mat))/sum(conf.mat)
prec <- conf.mat[2,2] / sum(conf.mat[,2])
rec <- conf.mat[2,2] / sum(conf.mat[2,])
f1.score <- 2*prec*rec/(prec+rec)
out <- list(acc, prec, rec, f1.score)
return(out)
}
model.plot.roc <- function(predm, labl) {
pred <- prediction(predm, labl)
perf <- performance(pred, measure="tpr", x.measure="fpr")
plot(perf, main="ROC")
abline(a=0, b= 1)
auc.perf <- performance(pred, measure = "auc")
return(auc.perf@y.values)
}
### LDA
lda.fit <- lda(HeartDisease~., data=train)
plot(lda.fit, type="density")
lda.pred <- predict(lda.fit, test, type="response")
lda.res <- lda.pred$posterior
lda.pred.best <- as.factor(ifelse(lda.res[,2] > 0.6, 1, 0))
# the best result is when t = 0.6 if we want to minimize False Positives
conf.mat <- table(test$HeartDisease, lda.pred.best)
conf.mat
# error rate
mean(lda.pred.best!=test$HeartDisease)
# accuracy, precision, recall, f1 score
metrics <- calculate.metrics(conf.mat)
metrics
# ROC
lda.auc <- model.plot.roc(lda.res[,2], test$HeartDisease)
# ROC
lda.auc <- model.plot.roc(lda.res[,2], test$HeartDisease)
ldahist(lda.pred$x[,1], g=lda.pred$class, col=2)
ldahist(lda.pred$x[,1], g=lda.pred$class, col=2)
ldahist(lda.pred$x[,1], g=lda.pred$class, col=2)
ldahist(lda.pred$x[,1], g=lda.pred$class, col=2)
ldahist(lda.pred$x[,1], g=lda.pred$class, col=2)
### QDA
qda.fit <- qda(HeartDisease~., data=train)
qda.pred <- predict(qda.fit, test)
qda.pred.best <- as.factor(ifelse(lda.res[,2] > 0.5, 1, 0))
conf.mat <- table(qda.pred.best, test$HeartDisease)
conf.mat
metrics <- calculate.metrics(conf.mat)
roc.out <- roc(controls=test$HeartDisease, cases=qda.pred$posterior[,2],
direction=">")
plot(roc.out, print.auc=TRUE, legacy.axes=TRUE,
xlab="False positive rate", ylab="True positive rate")
auc(roc.out)
metrics
train$HeartDisease <- as.factor(train$HeartDisease)
test$HeartDisease <- as.factor(test$HeartDisease)
naivebayes.model <- naive_bayes(HeartDisease~., data=train)
naivebayes.prediction <- predict(naivebayes.model, test)
head(cbind(naivebayes.prediction, test$HeartDisease))
naivebayes.conf_matrix <- table(naivebayes.prediction, test$HeartDisease)
naivebayes.conf_matrix
naivebayes.metrics <- calculate.metrics(naivebayes.conf_matrix)
naivebayes.metrics
Cholesterol
# missing values
data$Cholesterol[data$Cholesterol == 0] <- median(Cholesterol)
Cholesterol
attach(data)
Cholesterol
### LDA
lda.fit <- lda(HeartDisease~., data=train)
plot(lda.fit, type="density")
lda.pred <- predict(lda.fit, test, type="response")
lda.res <- lda.pred$posterior
lda.pred.best <- as.factor(ifelse(lda.res[,2] > 0.6, 1, 0))
# the best result is when t = 0.6 if we want to minimize False Positives
conf.mat <- table(test$HeartDisease, lda.pred.best)
conf.mat
# error rate
mean(lda.pred.best!=test$HeartDisease)
# accuracy, precision, recall, f1 score
metrics <- calculate.metrics(conf.mat)
metrics
### QDA
qda.fit <- qda(HeartDisease~., data=train)
qda.pred <- predict(qda.fit, test)
qda.pred.best <- as.factor(ifelse(lda.res[,2] > 0.5, 1, 0))
conf.mat <- table(qda.pred.best, test$HeartDisease)
metrics <- calculate.metrics(conf.mat)
qda.auc <- model.plot.roc(qda.pred$posterior[,2], test$HeartDisease)
qda.auc <- model.plot.roc(qda.pred$posterior[,2], test$HeartDisease)
metrics
train$HeartDisease <- as.factor(train$HeartDisease)
test$HeartDisease <- as.factor(test$HeartDisease)
naivebayes.model <- naive_bayes(HeartDisease~., data=train)
naivebayes.prediction <- predict(naivebayes.model, test)
head(cbind(naivebayes.prediction, test$HeartDisease))
naivebayes.conf_matrix <- table(naivebayes.prediction, test$HeartDisease)
naivebayes.conf_matrix
naivebayes.metrics <- calculate.metrics(naivebayes.conf_matrix)
naivebayes.metrics
# Boxplots
age.box <- boxplot(Age ~ HeartDisease, col=colours)
# Boxplots
age.box <- boxplot(Age ~ HeartDisease, col=colours)
restingBP.box <- boxplot(RestingBP ~ HeartDisease, col=colours)
chol.box <- boxplot(Cholesterol ~ HeartDisease, col=colours)
maxHR.box <- boxplot(MaxHR ~ HeartDisease, col=colours)
oldpeak.box <- boxplot(Oldpeak ~ HeartDisease, col=colours)
data.orig <- read.csv("data/heart_data.csv", stringsAsFactors = T)
head(data.orig)
# copy of dataset in case I need to change it
data <- data.frame(data.orig)
attach(data)
data[Cholesterol == 0]
data[Cholesterol == 0,:]
data[Cholesterol == 0,]
# missing values
# NOTE: changing missing values doesn't change accuracy of predictions
# NOTE: can it be measure of both HDL and LDL?
# TODO: why most values with 0 Chol have 1 HD?
head(data[Cholesterol == 0,])
attach(data)
cor(Cholesterol. HeartDisease)
cor(Cholesterol, HeartDisease)
head(data)
# chi-squared test
sex.t <- table(HeartDisease, Age)
sex.t
# chi-squared test
sex.t <- table(HeartDisease, Sex)
sex.t
chisq.test(sex.t)$expected
chisq.test(sex.t)
cpt.t <- table(HeartDisease, ChestPainType)
cpt.t
chisq.test(cpt.t)
chisq.test(cpt.t)$expected
chisq.test(cpt.t, correct=F)
chisq.test(sex.t,correct=F)
head(data)
fbs.t <- table(HeartDisease, FastingBS)
fbs.t
# FastingBS
fastingBS.plot <- ggplot(data, aes(x=FastingBS, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_bar(alpha=0.5, position="dodge") +
guides(fill = guide_legend(title="Heart disease"))
library(MASS)
library(pROC)
library(class)
library(ggplot2)
library(gridExtra)
library(corrplot)
library(ggm)
library(igraph)
library(tidymodels)
library(naivebayes)
library(ROCR)
library(glmnet)
help("gridExtra")
# FastingBS
fastingBS.plot <- ggplot(data, aes(x=FastingBS, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_bar(alpha=0.5, position="dodge") +
guides(fill = guide_legend(title="Heart disease"))
fastingBS.plot
fbs.t
chisq.test(fbs.t)
summary(data)
head(data)
recg.t <- table(HeartDisease, RestingECG)
recg.t
chisq.test(recg.t)
exan.t <- table(HeartDisease, ExerciseAngina)
exan.t
chisq.test(exan.t)
oldp.t <- table(HeartDisease, Oldpeak)
oldp.t
st.t <- table(HeartDisease, ST_Slope)
st.t
chisq.test(st.t)
# correlations
cor.data <- cor(data[,cont.idx])
cor(Cholesterol, HeartDisease)
# Train-Test split
set.seed(123)
split <- initial_split(data, prop=0.75)
train <- training(split)
test <- testing(split)
calculate.metrics <- function(conf.mat) {
acc <- sum(diag(conf.mat))/sum(conf.mat)
prec <- conf.mat[2,2] / sum(conf.mat[,2])
rec <- conf.mat[2,2] / sum(conf.mat[2,])
f1.score <- 2*prec*rec/(prec+rec)
out <- list(acc, prec, rec, f1.score)
return(out)
}
model.plot.roc <- function(predm, labl) {
pred <- prediction(predm, labl)
perf <- performance(pred, measure="tpr", x.measure="fpr")
plot(perf, main="ROC")
abline(a=0, b= 1)
auc.perf <- performance(pred, measure = "auc")
return(auc.perf@y.values)
}
glm.model <- glm(data=train, HeartDisease~., family="binomial")
glm_summary <- summary(glm.model)
# prediction and conversion to binary
prediction.glm.model <- predict(glm.model, newdata=test, type="response")
prediction.glm.model.binary <- ifelse(prediction.glm.model > 0.6, 1, 0)
conf_matrix <- table(test$HeartDisease, prediction.glm.model.binary) #tried also with correlationMatrix from carel package but having problems with levels
glm.model.metrics <- calculate.metrics(conf_matrix)
prediction.gml.model
prediction.glm.model
# Age
age.plot.1 <- ggplot(data, aes(x=Age, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_density(alpha=0.4) +
ggtitle("Age - Density Plot") + xlab("Age") +
guides(fill = guide_legend(title="Heart disease"))
age.plot.1
# RestingBP
restingBP.plot <- ggplot(data, aes(x=RestingBP, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_density(alpha=0.4) +
ggtitle("RestingBP - Density Plot") + xlab("RestingBP") +
guides(fill = guide_legend(title="Heart disease"))
# Boxplots
age.box <- boxplot(Age ~ HeartDisease, col=colours)
# Boxplots
age.box <- boxplot(Age ~ HeartDisease, col=colours)
restingBP.box <- boxplot(RestingBP ~ HeartDisease, col=colours)
RestingBP[RestingBP == 0]
data[RestingBP == 0]
data[RestingBP == 0,]
data$RestingBP[data$RestingBP == 0] <- median(data$RestingBP)
restingBP.box <- boxplot(RestingBP ~ HeartDisease, col=colours)
attach(data)
restingBP.box <- boxplot(RestingBP ~ HeartDisease, col=colours)
# chi-squared test
sex.t <- table(HeartDisease, Sex)
quantiles <- quantile(RestingBP, probs=c(.25, .75), na.rm=F)
quantiles
iqr <- IQR(RestingBP)
iqr
Lower <- quartiles[1] - 1.5*IQR
Lower <- quantiles[1] - 1.5*IQR
Lower <- quartiles[1] - 1.5*iqr
Lower <- quantiles[1] - 1.5*iqr
Upper <- quantiles[2] + 1.5*iqr
Lower
Upper
RestingBP[RestingBP > Upper | RestingBP < Lower]
data[RestingBP > Upper, "HeartDisease"]
head(data)
data$Cholesterol
data[data$Cholesterol == 0, "RestingBP"]
data[data$Cholesterol == 0, RestingBP > 170]
chol.box <- boxplot(Cholesterol ~ HeartDisease, col=colours)
data$Cholesterol[data$Cholesterol == 0] <- median(Cholesterol)
data$RestingBP[data$RestingBP == 0] <- median(data$RestingBP)
attach(data)
chol.box <- boxplot(Cholesterol ~ HeartDisease, col=colours)
Cholesterol
max(Cholesterol)
data[Cholesterol == 603,]
# Cholesterol
chol.plot <- ggplot(data, aes(x=Cholesterol, group=HeartDisease,
fill=factor(HeartDisease))) +
geom_density(alpha=0.4) +
ggtitle("Cholesterol - Density Plot") + xlab("Cholesterol") +
guides(fill = guide_legend(title="Heart disease"))
chol.plot
chol.plot
dev.off()
chol.plot
maxHR.box <- boxplot(MaxHR ~ HeartDisease, col=colours)
oldpeak.box <- boxplot(Oldpeak ~ HeartDisease, col=colours)
boxplot(Cholesterol)
boxplot(Age)
boxplot(RestingBP)
boxplot(MaxHR)
boxplot(Oldpeak)
boxplot(MaxHR)
MaxHR
data[MaxHR > 180]
data[MaxHR > 180,]
anova(HeartDisease)
aov(HeartDisease)
aov(HeartDisease ~ Cholesterol)
data.orig <- read.csv("data/heart_data.csv", stringsAsFactors = T)
head(data.orig)
# copy of dataset in case I need to change it
data <- data.frame(data.orig)
attach(data)
aov(HeartDisease ~ Cholesterol)
ch <- Cholesterol[Cholesterol ~= 0]
ch <- Cholesterol[Cholesterol ~ 0]
ch <- Cholesterol[Cholesterol != 0]
ch
hd <- data[Cholesterol != 0, "HeartDisease"]
aov(hd ~ ch)
cor.test(Cholesterol, HeartDisease)
cor.test(HeartDisease, Cholesterol)
cor.test(ch, hd)
summary(data)
head(data[,-c(5)])
# Train-Test split
set.seed(123)
split <- initial_split(data[,-c(5)], prop=0.75)
train <- training(split)
test <- testing(split)
calculate.metrics <- function(conf.mat) {
acc <- sum(diag(conf.mat))/sum(conf.mat)
prec <- conf.mat[2,2] / sum(conf.mat[,2])
rec <- conf.mat[2,2] / sum(conf.mat[2,])
f1.score <- 2*prec*rec/(prec+rec)
out <- list(acc, prec, rec, f1.score)
return(out)
}
model.plot.roc <- function(predm, labl) {
pred <- prediction(predm, labl)
perf <- performance(pred, measure="tpr", x.measure="fpr")
plot(perf, main="ROC")
abline(a=0, b= 1)
auc.perf <- performance(pred, measure = "auc")
return(auc.perf@y.values)
}
### LDA
lda.fit <- lda(HeartDisease~., data=train)
lda.pred <- predict(lda.fit, test, type="response")
lda.res <- lda.pred$posterior
lda.pred.best <- as.factor(ifelse(lda.res[,2] > 0.6, 1, 0))
# the best result is when t = 0.6 if we want to minimize False Positives
conf.mat <- table(test$HeartDisease, lda.pred.best)
conf.mat
# error rate
mean(lda.pred.best!=test$HeartDisease)
# accuracy, precision, recall, f1 score
metrics <- calculate.metrics(conf.mat)
# ROC
lda.auc <- model.plot.roc(lda.res[,2], test$HeartDisease)
lda.auc
metrics
### QDA
qda.fit <- qda(HeartDisease~., data=train)
qda.pred <- predict(qda.fit, test)
qda.pred.best <- as.factor(ifelse(lda.res[,2] > 0.5, 1, 0))
conf.mat <- table(qda.pred.best, test$HeartDisease)
conf.mat
metrics <- calculate.metrics(conf.mat)
qda.auc <- model.plot.roc(qda.pred$posterior[,2], test$HeartDisease)
metrics
train$HeartDisease <- as.factor(train$HeartDisease)
test$HeartDisease <- as.factor(test$HeartDisease)
naivebayes.model <- naive_bayes(HeartDisease~., data=train)
naivebayes.prediction <- predict(naivebayes.model, test)
head(cbind(naivebayes.prediction, test$HeartDisease))
naivebayes.conf_matrix <- table(naivebayes.prediction, test$HeartDisease)
naivebayes.conf_matrix
naivebayes.metrics <- calculate.metrics(naivebayes.conf_matrix)
naivebayes.metrics
naivebayes.probabilities <- attr(naivebayes.prediction, "probabilities")[, "Yes"]
split <- initial_split(data, prop=0.75)
train <- training(split)
train$HeartDisease <- as.factor(train$HeartDisease)
test$HeartDisease <- as.factor(test$HeartDisease)
naivebayes.model <- naive_bayes(HeartDisease~., data=train)
naivebayes.prediction <- predict(naivebayes.model, test)
head(cbind(naivebayes.prediction, test$HeartDisease))
naivebayes.conf_matrix <- table(naivebayes.prediction, test$HeartDisease)
naivebayes.conf_matrix
naivebayes.metrics <- calculate.metrics(naivebayes.conf_matrix)
naivebayes.metrics
lda.pred <- predict(lda.fit, test, type="response")
lda.res <- lda.pred$posterior
lda.pred.best <- as.factor(ifelse(lda.res[,2] > 0.6, 1, 0))
# the best result is when t = 0.6 if we want to minimize False Positives
lda.conf.mat <- table(test$HeartDisease, lda.pred.best)
lda.conf.mat
# error rate
mean(lda.pred.best!=test$HeartDisease)
# accuracy, precision, recall, f1 score
lda.metrics <- calculate.metrics(conf.mat)
lda.metrics
split <- initial_split(data[,-c(5)], prop=0.75)
train <- training(split)
test <- testing(split)
train
data$Cholesterol[data$Cholesterol == 0] <- median(data$Cholesterol)
attach(data)
# point-biserial correlation
cor.test(HeartDisease, Cholesterol) # negative correlation
glm.model <- glm(data=train, HeartDisease~., family="binomial")
glm_summary <- summary(glm.model)
glm_summary
data[,cont.idx]
vif(data[,cont.idx])
vif(data)
VIF(data)
install.packages("car") # for vif
library(car)
library(car)
vif(data)
vif(data[,cont.idx])
vif(glm.model)
glm.model.1 <- update(glm.model, ~. - Age)
glm.model.2 <- update(glm.model.1, ~. - RestingECG)
glm.model.3 <- update(glm.model.2, ~. - MaxHR)
glm_summary <- summary(glm.model.3)
summary(glm.model.3)
anova(glm.model, glm.model.3)
deviance(glm.model)
deviance(glm.model.3)
anova(glm.model, glm.model.3, test="Chisq")
